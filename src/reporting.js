/**

Copyright 2018 New Vector Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

**/

const path = require('path');
const fs = require('fs');
const rp = require('request-promise');

const ClientError = require('./client-error.js');
const executeCommand = require('./execute-cmd.js');
const decryptFile = require('./decrypt-file.js');

const crypto = require('crypto');
function base64sha256(s) {
    const hash = crypto.createHash('sha256');
    hash.update(s);
    return hash.digest('base64');
}

function generateResultHash(httpUrl, eventContentFile=undefined) {
    // Result is cached against the hash of the input. Just using an MXC would
    // potentially allow an attacker to mark a file as clean without having the
    // keys to correctly decrypt it.
    return base64sha256(JSON.stringify({ httpUrl, eventContentFile }));
}

function generateHttpUrl(baseUrl, domain, mediaId) {
    return `${baseUrl}/_matrix/media/v1/download/${domain}/${mediaId}`;
}

// In-memory mapping between mxc:// URLs and the results generated by generateReport
let resultCache = {};
function clearReportCache() {
    resultCache = {};
}

// Get cached report for the given URL
async function getReport(console, domain, mediaId, eventContentFile, opts) {
    const { baseUrl } = opts;

    const httpUrl = generateHttpUrl(baseUrl, domain, mediaId);
    const resultSecret = generateResultHash(httpUrl, eventContentFile);

    const { clean, info } = resultCache[resultSecret]
        || await generateReport(console, domain, mediaId, eventContentFile, opts);

    console.info(`Returning scan report: domain = ${domain}, mediaId = ${mediaId}, clean = ${clean}`);

    return { clean, scanned: true, info };
}

async function scannedDownload(req, res, domain, mediaId, eventContentFile, opts) {
    opts.withCleanFile = function(filePath, fn) {
        req.console.info(`Sending ${filePath} to client`);
        res.sendFile(filePath, fn);
    };

    const { clean, info } = await generateReport(req.console, domain, mediaId, eventContentFile, opts);

    if (!clean) {
        throw new ClientError(403, info);
    }
}

// Generate a report on a Matrix file event.
async function generateReport(console, domain, mediaId, eventContentFile, opts) {
    const { baseUrl, tempDirectory, script } = opts;
    if (baseUrl === undefined || tempDirectory === undefined || script === undefined) {
        throw new Error('Expected baseUrl, tempDirectory and script in opts');
    }

    const httpUrl = generateHttpUrl(baseUrl, domain, mediaId);

    const resultSecret = generateResultHash(httpUrl, eventContentFile);

    const tempDir = await fs.promises.mkdtemp(`${tempDirectory}${path.sep}av-`);
    const filePath = path.join(tempDir, 'downloadedFile');

    async function cleanUp() {
        console.info(`Removing ${filePath} and ${tempDir}`);
        await fs.promises.unlink(filePath);
        await fs.promises.rmdir(tempDir);
    }

    console.info(`Downloading ${httpUrl}, writing to ${filePath}`);

    try {
        data = await rp({url: httpUrl, encoding: null});
    } catch (err) {
        await cleanUp();
        console.error(`Receieved status code ${err.statusCode} when requesting ${httpUrl}`);
        throw new ClientError(502, 'Failed to get requested URL');
    }

    await fs.promises.writeFile(filePath, data);

    if (resultCache[resultSecret] === undefined) {
        result = await generateResult(console, eventContentFile, filePath, tempDir, script);
        resultCache[resultSecret] = result;
    } else {
        console.info(`Result previously cached`);
        result = resultCache[resultSecret];
    }

    console.info(`Result: url = "${httpUrl}", clean = ${result.clean}, exit code = ${result.exitCode}`);

    if (result.clean && opts.withCleanFile) {
        opts.withCleanFile(filePath, cleanUp);
    } else {
        cleanUp();
    }

    return result;
}

async function generateResult(console, eventContentFile, filePath, tempDir, script) {
    // By default, the file is considered decrypted
    let decryptedFilePath = filePath;

    if (eventContentFile && eventContentFile.key) {
        decryptedFilePath = path.join(tempDir, 'unsafeDownloadedDecryptedFile');
        console.info(`Decrypting ${filePath}, writing to ${decryptedFilePath}`);

        try {
            decryptFile(filePath, decryptedFilePath, eventContentFile);
        } catch (err) {
            console.error(err);
            throw new ClientError(400, 'Failed to decrypt file');
        }
    }

    const cmd = script + ' ' + decryptedFilePath;
    console.info(`Running command ${cmd}`);
    const result = await executeCommand(cmd);

    // We don't need the decrypted data, so remove it.
    if (filePath !== decryptedFilePath) {
        console.info(`Removing ${decryptedFilePath}`);
        await fs.promises.unlink(decryptedFilePath);
    }

    return result;
}

module.exports = {
    getReport,
    scannedDownload,
    generateReport,
    clearReportCache,
};
